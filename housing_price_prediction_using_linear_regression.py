# -*- coding: utf-8 -*-
"""Housing Price Prediction using Linear Regression

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/#fileId=https%3A//storage.googleapis.com/kaggle-colab-exported-notebooks/housing-price-prediction-using-linear-regression-86bc5117-2b79-493f-9e58-d66a4d145c56.ipynb%3FX-Goog-Algorithm%3DGOOG4-RSA-SHA256%26X-Goog-Credential%3Dgcp-kaggle-com%2540kaggle-161607.iam.gserviceaccount.com/20240405/auto/storage/goog4_request%26X-Goog-Date%3D20240405T072122Z%26X-Goog-Expires%3D259200%26X-Goog-SignedHeaders%3Dhost%26X-Goog-Signature%3D6c8d5d26541ad93154b4ae7b6eb4f9a212f8705ca2b43328e1e5e13c401022f125830caaedc0a21273c9fe7d765595fc1c4f34d894d9bdccf2e63a755fcf11f92a61a9ef76bfb431b53a43e1dea7f33c786450f0831f1a4b6200958508d4928c186657c95530983a77e4bd5776faca0cacef215052e780737f54b36089f013070dc033524a0b05aca37e2dadb75cfa2c2e9225ee74adeb29b0ef6da3ec49f840235ff1e7518fd9097e8dd014b7268d52ee22ecb6ca3e42a9832abec8f082cddbb7523881660c7a50951439e1318a115746bd6bbd3e92861a9652ec42e38654f6d272fa7c4231dc02be102a1d9f1447f7798c65bccf16edb66f82e806c25c22b8
"""

import os
import sys
from tempfile import NamedTemporaryFile
from urllib.request import urlopen
from urllib.parse import unquote, urlparse
from urllib.error import HTTPError
from zipfile import ZipFile
import tarfile
import shutil

CHUNK_SIZE = 40960
DATA_SOURCE_MAPPING = 'housing-dataset:https%3A%2F%2Fstorage.googleapis.com%2Fkaggle-data-sets%2F133734%2F317933%2Fbundle%2Farchive.zip%3FX-Goog-Algorithm%3DGOOG4-RSA-SHA256%26X-Goog-Credential%3Dgcp-kaggle-com%2540kaggle-161607.iam.gserviceaccount.com%252F20240405%252Fauto%252Fstorage%252Fgoog4_request%26X-Goog-Date%3D20240405T072122Z%26X-Goog-Expires%3D259200%26X-Goog-SignedHeaders%3Dhost%26X-Goog-Signature%3D1f301f448ea3c0fe5bdc71848327feb5eccf28072768d39857d828eec93d4f11296d86f550cf92533e49fe0bbafefe7610b4bde46845519df0265040837ef9d26b491e102652abe83effa8e5ec85725433baf236a54749233fb3b2aa737be65f738d4775958c3d915e015d45eb8331a72e8338e54195e3858c2826fa2cda8993dad1970f299226a58b8e98d2b41fe460c86ca755a37d1d6db6d4ddd44c1987f79a4ae71d8b316e52282abe365678f091b1553a3e4ac58f4f15729ea8b13538d8a9296f9d7bdad66c495f2251307b7b5fccfb9668bc2713645b758602f8f4411cb96ef05ada2e1b2003cffd9f7d881a22c7324d846c6b9b4fafb78d64ba3fcb05'

KAGGLE_INPUT_PATH='/kaggle/input'
KAGGLE_WORKING_PATH='/kaggle/working'
KAGGLE_SYMLINK='kaggle'

!umount /kaggle/input/ 2> /dev/null
shutil.rmtree('/kaggle/input', ignore_errors=True)
os.makedirs(KAGGLE_INPUT_PATH, 0o777, exist_ok=True)
os.makedirs(KAGGLE_WORKING_PATH, 0o777, exist_ok=True)

try:
  os.symlink(KAGGLE_INPUT_PATH, os.path.join("..", 'input'), target_is_directory=True)
except FileExistsError:
  pass
try:
  os.symlink(KAGGLE_WORKING_PATH, os.path.join("..", 'working'), target_is_directory=True)
except FileExistsError:
  pass

for data_source_mapping in DATA_SOURCE_MAPPING.split(','):
    directory, download_url_encoded = data_source_mapping.split(':')
    download_url = unquote(download_url_encoded)
    filename = urlparse(download_url).path
    destination_path = os.path.join(KAGGLE_INPUT_PATH, directory)
    try:
        with urlopen(download_url) as fileres, NamedTemporaryFile() as tfile:
            total_length = fileres.headers['content-length']
            print(f'Downloading {directory}, {total_length} bytes compressed')
            dl = 0
            data = fileres.read(CHUNK_SIZE)
            while len(data) > 0:
                dl += len(data)
                tfile.write(data)
                done = int(50 * dl / int(total_length))
                sys.stdout.write(f"\r[{'=' * done}{' ' * (50-done)}] {dl} bytes downloaded")
                sys.stdout.flush()
                data = fileres.read(CHUNK_SIZE)
            if filename.endswith('.zip'):
              with ZipFile(tfile) as zfile:
                zfile.extractall(destination_path)
            else:
              with tarfile.open(tfile.name) as tarfile:
                tarfile.extractall(destination_path)
            print(f'\nDownloaded and uncompressed: {directory}')
    except HTTPError as e:
        print(f'Failed to load (likely expired) {download_url} to path {destination_path}')
        continue
    except OSError as e:
        print(f'Failed to load {download_url} to path {destination_path}')
        continue

print('Data source import complete.')

"""# **Predicting House Prices: Exploratory Data Analysis and Linear Regression Modeling**

# **Importing the required libraries**
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import MinMaxScaler
from sklearn.linear_model import LinearRegression
from sklearn.metrics import r2_score

"""# **Importing our dataset**"""

data = pd.read_csv('/kaggle/input/housing-dataset/Housing.csv')
data.head()

data.tail(5)

"""# **Understanding our data**"""

print("Rows and Columns of the dataset :- ",data.shape)

data.info()

data.columns

"""#### **Columns or Features Description**

- 'price': The price of the house (target variable).
- 'area': The area or size of the house in square feet.
- 'bedrooms': The number of bedrooms in the house.
- 'bathrooms': The number of bathrooms in the house.
- 'stories': The number of stories or floors in the house.
- 'mainroad': Categorical variable indicating whether the house is located near the main road or not.
- 'guestroom': Categorical variable indicating whether the house has a guest room or not.
- 'basement': Categorical variable indicating whether the house has a basement or not.
- 'hotwaterheating': Categorical variable indicating whether the house has hot water heating or not.
- 'airconditioning': Categorical variable indicating whether the house has air conditioning or not.
- 'parking': The number of parking spaces available with the house.
- 'prefarea': Categorical variable indicating whether the house is in a preferred area or not.
- 'furnishingstatus': The furnishing status of the house (e.g., unfurnished, semi-furnished, fully furnished).
"""

data.describe(include ='all')

"""# **Checking NULL Values**"""

data.isnull().sum()

"""The inference we can make after checking for null values and finding that there are no null values in any of the columns is that the dataset is complete in terms of missing values.

Having no null values is beneficial because it allows us to work with the entire dataset without the need for imputation or handling missing data. We can proceed with further data analysis, visualization, and modeling.

# **Performing EDA**

### **1. Handling Binary Categorical Variables (Yes/No) Categories**
"""

categorical_col =  ['mainroad', 'guestroom', 'basement', 'hotwaterheating', 'airconditioning', 'prefarea']

data[categorical_col]

def binary_map(x):
    """
    Function to map 'yes' and 'no' values to 1 and 0, respectively.

    Parameters:
    x (pandas Series): Input Series containing 'yes' and 'no' values.

    Returns:
    pandas Series: Mapped Series with 'yes' mapped to 1 and 'no' mapped to 0.
    """
    return x.map({'yes': 1, 'no': 0})

data[categorical_col] = data[categorical_col].apply(binary_map)


data[categorical_col]

data.head()

"""### **2. Handling Categorical data with Dummy Variable**"""

dummy_col = pd.get_dummies(data['furnishingstatus'])


dummy_col.head()

dummy_col = pd.get_dummies(data['furnishingstatus'], drop_first=True)


dummy_col.head()

data = pd.concat([data, dummy_col], axis=1)


data.head()

data.drop(['furnishingstatus'], axis=1, inplace=True)


data.head()

"""# **Splitting data into Training and Testing data**"""

data.columns

np.random.seed(0)


df_train, df_test = train_test_split(data, train_size=0.7, test_size=0.3, random_state=100)

df_train.head()

df_train.shape

df_test.head()

df_test.shape

"""# **Scaling Training Data: MinMaxScaler**"""

scaler = MinMaxScaler()

col_to_scale = ['area', 'bedrooms', 'bathrooms', 'stories', 'parking', 'price']

df_train[col_to_scale] = scaler.fit_transform(df_train[col_to_scale])

"""# **Training the model**"""

y_train = df_train.pop('price')


x_train = df_train

linear_regression = LinearRegression()

linear_regression.fit(x_train, y_train)

coefficients = linear_regression.coef_


print(coefficients)

score = linear_regression.score(x_train, y_train)


print(score)

"""# **Scaling Test Data: MinMaxScaler**"""

col_to_scale = ['area', 'bedrooms', 'bathrooms', 'stories', 'parking','price']

df_test[col_to_scale] = scaler.fit_transform(df_test[col_to_scale])

"""# **Testing our model**"""

y_test = df_test.pop('price')


x_test = df_test

prediction = linear_regression.predict(x_test)

"""### **Checking R squared value**"""

r2 = r2_score(y_test, prediction)

"""# **Comparing the actual and predicted values**"""

y_test.shape

y_test_matrix = y_test.values.reshape(-1, 1)

data_frame = pd.DataFrame({'actual': y_test_matrix.flatten(), 'predicted': prediction.flatten()})

# Display the first 10 rows of the DataFrame
data_frame.head(10)

"""### **Plotting the Graph**"""

# Create a new figure
fig = plt.figure()

# Scatter plot of actual versus predicted values
plt.scatter(y_test, prediction)

# Set the title and labels for the plot
plt.title('Actual vs Prediction')
plt.xlabel('Actual', fontsize=15)
plt.ylabel('Predicted', fontsize=15)

from sklearn.metrics import mean_squared_error

mse = mean_squared_error(y_test, prediction)
print("Mean Squared Error:", mse)

from sklearn.neighbors import KNeighborsRegressor
from sklearn.tree import DecisionTreeRegressor
knn_model = KNeighborsRegressor(n_neighbors=5)
knn_model.fit(x_train, y_train)
knn_y_pred = knn_model.predict(x_test)
knn_mse = mean_squared_error(y_test, knn_y_pred)
knn_r2 = r2_score(y_test, knn_y_pred)

print(" Mean Squared Error:", knn_mse)
print(" R-squared:", knn_r2)

dt_model = DecisionTreeRegressor(random_state=42)
dt_model.fit(x_train, y_train)
dt_y_pred = dt_model.predict(x_test)

dt_mse = mean_squared_error(y_test, dt_y_pred)
dt_r2 = r2_score(y_test, dt_y_pred)

print(" Mean Squared Error:", dt_mse)
print(" R-squared:", dt_r2)

import matplotlib.pyplot as plt
algorithms = ['Linear Regression', 'KNN', 'Decision Tree']
r2_scores = [r2, knn_r2, dt_r2]

plt.figure(figsize=(10, 6))
plt.bar(algorithms, r2_scores, color=['blue', 'green', 'red'])
plt.title('R-squared Comparison')
plt.xlabel('Algorithm')
plt.ylabel('R-squared')
plt.ylim(0, 1)
plt.show()

plt.figure(figsize=(10, 6))
plt.scatter(y_test, knn_y_pred, color='blue')
plt.title('Actual vs. Predicted Median House Value')
plt.xlabel('Actual Median House Value')
plt.ylabel('Predicted Median House Value')
plt.show()

plt.figure(figsize=(10, 6))
plt.scatter(y_test, dt_y_pred, color='blue')
plt.title('Actual vs. Predicted Median House Value')
plt.xlabel('Actual Median House Value')
plt.ylabel('Predicted Median House Value')
plt.show()